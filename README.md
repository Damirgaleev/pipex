# pipex
В данном проекте нам предлагают реализовать команду pipe (конвейер). Для этого нам потребуется создать "трубу" и породить новые процессы. Постараюсь объяснить суть программы пошагово.

1) в функции main у нас появляется третья переменная - массив строк "envp", в ней лежат переменные окружения. Необходимо найти в этом массиве строку, которая начинается с "PATH=", там лежат пути к исполняемым командам например "grep". В этой строке несколько путей, разделенные ":". Нужно сохранить каждый путь в отдельную строку массива строк.

2) далее командой pipe создаем трубу. У трубы есть вход и выход. На вход трубы подается команда, данные для этой команды считываются из входящего файла, труба отправляет результат этой команды на выход, там испоняется вторая команда, а результат мы отправим на выход в другой файл. Что бы связать два конца трубы в качестве параметров для команды pipe подается массив из двух файловых дискрипторов. Они и будут отправлять и читать с разных концов трубы.

3) создадим новый процесс командой fork, после этой команды у нас будет два процесса, родительский и дочерний, fork вернет примитивную переменную. Если она равна 0, значит мы в дочернем процессе и можем рабоать с ним.

4) и так, мы в дочернем процессе. Первым делом функцией dup2 зменим файловый дискриптор стандартного выхода на файловый дискриптор выхода нашей трубы. Закроем файловый дискриптор чтения из трубы, так как мы им не пользуемся и последнее, нужно заменить дискриптор стандартного чтения на дискриптор нашего первого файла (дискриптор этого файла, а так же файла куда запишем результат, необходимо получить заранее). Далее разделим по символу ' ' и запишем второй аргумент программы в массив строк, так как вторым аргументом может подаваться сама команда и аргумент для нее, например "grep text". Необходимо проверить наличие названия команды, в нашем случае "grep" в путях исполняемых файлов, которые мы получили из окружения ранее. Для этого используем команду access, она вернет 0, если команда сущетсвует. Осталось только исполнить данную командв, командой execve.

5) возвращаемся в родительский процесс, создаем еще один дочерний процесс и идем в него.

6) здесь заменим дискриптор чтения на дискриптор чтения из трубы, закроем дискриптор вывода трубы и заменим дискриптор стандартного вывода на дискриптор файла, в который запишем результат. Далее делаем то же свмое, что и в первом дочернем процессе.

7) и в конце мы возвращаемся в родительский процесс. Здесь нужно закрыть файловые дискрипторы, которые мы создали для трубы - они все еще открыты в родительском процессе. Функцией waitpid подождать завершение первого и второго дочерних процессов, так как родительский может закончиться быстрее и мы не получим нужный результат.

P.S. не забывайте очищать замолоченную память.
